# C++ 빌드 관련 리서치



## C++ 컴파일 과정

1. 전처리
   * C++ 언어 문법 검사
   * 주석 제거
   * 전처리 수행 (#include, #매크로 등등)
   * cpp/header 파일을 읽어 컴파일 가능한 소스로 변환 (.i 파일 생성)
2. 컴파일
   * 프로그램 소스를 어셈블리 코드로 변환
   * .i 파일을 .s 파일로 변환
3. 어셈블
   * 어셈블러에 의해 기계어로 어셈블됨
   * .s 파일을 어셈블해 2진수로 이뤄진 .o 파일 생성
4. 링크
   * 링커가 오브젝트 코드와 컴파일된 C / C++ 표준 라이브러리를 연결해 실행 가능한 프로그램 생성. (.exe)
   * printf 나 scanf 이런건 미리 컴파일 되어있기에 이런 라이브러리를 연결시켜줌.

## Link?

![9985B3375C56ED5D1F](image\9985B3375C56ED5D1F.png)

cpp 파일로 부터 컴파일된 목적파일 (.o 파일) 들과 Runtime Library (이미 컴파일 되어있는 라이브러리 cout 이런거) 을 합쳐서 실행 가능한 파일로 만드는 것이 Linker의 역할.

![link_5f854d22127de-2](image\link_5f854d22127de-2.gif)





### Static Link 정적 링크

exe 실행 파일을 만들 때 라이브러리를 같이 포함시켜서 만드는 것.

실행 파일에 라이브러리를 모두 복사해서 만들고, 미리 컴파일 되어있기 때문에 컴파일 시간도 단축됨. 또, 직접 구현한 코드를 라이브러리화 시켜서 기술 유출 방지로도 사용할 수 있음.

실행파일 내에 모든 라이브러리를 복사하므로 그만큼 메모리를 차지한다.

#### 그래서 문제점은?

정적 링크 된 프로그램이 100개가 동작하는 경우 메모리에 정적 링크된 라이브러리들 또한 100번 복사되어서 메모리에 올라간다. 

예를 들면 cout에 대한 코드 정보만 100개가 중복되어서 올라간다.



### Dynamic Link 동적 링크

정적 링크의 단점이었던 메모리에 중복 코드정보가 너무 많이 올라가는 것에 대한 개선 방향.

cout 같이 많이 쓰이는 라이브러리를 메모리에 하나만 올리고, cout을 호출할 때 메모리의 cout 부분으로 점프해 실행하고 다시 원래 실행 부분으로 돌아오게 하는 방법.

현재는 별도의 옵션을 주지 않으면 동적 링크로 링크를 진행한다. (정적 링크, 동적 링크 섞어서 쓴다.)

동적 링크 라이브러리를 DLL 이라고 부른다(Dynamic-link Library) 윈도우에서 특정 명령을 실행했을 때 메모리에 존재 하지 않으면 해당 명령이 존재하는 DLL 파일을 메모리에 올린 후 사용한다.

윈도우에서는 DLL이라 부르고, Linux/Unix 에서는 Shared Library라고 부른다. 그래서 확장자가 리눅스쪽에선 .so 또는 .sa 이다.(그래서 안드로이드에서 사용하는 C++ 컴파일된 라이브러리 파일의 확장자가 .so 인 것!)

#### 장단점

중복 코드 정보가 메모리에 모두 올라가지 않으니 메모리 요구사항이 매우 적고,

프로그램 실행 중 라이브러리가 저장되어있는 주소로 점프 하는 것이기에 성능상에서 overhead가 든다.



## Make?

그냥 컴파일 하면 되지 왜 굳이 make? makefile?

### Make를 쓰지 않으면??

컴파일은 아래처럼 목적 코드를 만든다.

```
gcc -c -o main.o main.c
gcc -c -o plus.o plus.c
gcc -c -o minus.o minus.c
gcc -o calculator_exe main.o plus.o minus.o
```

이런식으로 calculator_exe 실행 파일을 만들게 된다.

하지만 C 파일이 1000개 10000개가넘는다면?

위와같은 코드를 일일이 노가다로 치는 것은 시간이 매우 오래 걸린다. 이런 문제를 해결 하기 위해 make / Makefile이 있다.

> Make 란?
>
> Makefile에 적힌 대로 컴파일러에 명령해 Shell 명령이 순차적으로 실행될 수 있게 해준다.

* 단순히 반복 되는 작업과 재작성을 자동화 시킬 수 있다.
* 프로그램의 종속 구조를 빠르게 파악 할 수 있고 관리가 편하다. 

### Makefile의 구조

* 목적 파일 (Target) : 명령어가 수행되어 나온 결과를 저장할 파일
* 의존성 (Dependency) : 목적 파일을 만들기 위해 필요한 재료
* 명령어 (Command) : 실행 되어야 할 명령어
* 매크로 (Macro) : 코드를 단순화 시키기 위한 방법

![253E224B56E5924D28](image\253E224B56E5924D28.jpg)

```
$ make clean
```

위 명령어는 모든 목적 파일과 diary_exe 파일을 제거한다.

```
$ make
```

위 명령어로 Makefile을 실행한다.



## CMake?

프로젝트의 규모가 거대해지면서 소스파일들이 많아지고 의존성이 복잡하게 엮이기 시작하면 Make도 점점 한계가 드러난다. 소스코드를 수정할 때 마다 Makefile을 수정 해주어야 하기 때문.

CMake를 쓰면 의존성 정보를 일일이 기술해 주지 않아도 되므로 매우 효율적이다. 처음 프로젝트를 시작할 때 잘 구성 해 두면 소스파일 (.c)이 생길 때만 CMakeLists.txt에 추가해주면 된다. 이후에는 소스코드를 수정하더라도 스크립트를 수정할 필요가 없다.

Make와 CMake 둘 다 의존성 검사를 해서 Increamental Build를 수행하지만, CMake는 소스파일 내부까지 들어가 분석해서 의존성 정보를 스스로 파악한다. 또, makefile에서는 목적파일(.o) 의 이름과 의존성 정보까지 모두 써야하지만 CMake에서는 소스파일만 명시하면 된다.

CMake도 결국 최종 빌드는 make명령을 수행한다. CMake는 makefile을 좀 더 쉽게 기술 할 수 있게 추상화된 것이라고 생각하면 된다.

```
CMake 실행 명령
$ cmake CMakeLists.txt
```

위 명령을 실행하면 Makefile이 생성 된다. 그리고 make 명령어를 수행시키면 된다.



## 참조

[매우 자세한 C언어 컴파일 과정 블로그](https://gracefulprograming.tistory.com/16)

[운영체제 매모리 내 프로세스 구조 (code segment, static data)](https://jhnyang.tistory.com/32)

[Linking??](https://jhnyang.tistory.com/40)

[Make Makefile](https://bowbowbow.tistory.com/12)

[CMake?](https://www.tuwlab.com/ece/27234)